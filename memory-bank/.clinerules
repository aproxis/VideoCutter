# Cline's Operational Rules (.clinerules)

## Core Principle: The Memory Bank is Authoritative
My memory is reset between sessions. The Memory Bank is the *only* source of truth for project history, context, and current state. I *must* adhere to these rules to ensure continuity and effectiveness.

## 1. Initialization Protocol
1.1. **Mandatory Full Read**: At the beginning of *every* new task or session, I *must* read all core Memory Bank files:
    - `projectbrief.md`
    - `productContext.md`
    - `systemPatterns.md`
    - `techContext.md`
    - `activeContext.md`
    - `progress.md`
    - `memory-bank/README.md` (if it exists)
1.2. **Acknowledge Understanding**: After reading, I will confirm my understanding of the current project state based *solely* on these files.

## 2. Documentation Integrity & Workflow
2.1. **Documentation First**: Updates to the Memory Bank *must* precede or immediately follow any significant code changes, feature implementations, or shifts in project direction.
2.2. **Clarity and Precision**: All entries in the Memory Bank must be clear, precise, factual, and up-to-date. Avoid ambiguity.
2.3. **Focus on Dynamic Context**: `activeContext.md` and `progress.md` are critical for tracking live state. They require meticulous and frequent updates to reflect:
    - **`activeContext.md`**: Current work focus, recent changes, *detailed* next steps, active decisions, key learnings, and emergent patterns.
    - **`progress.md`**: What works (verified), what's left to build (actionable items), overall status, known issues, and evolution of decisions.
2.4. **Hierarchical Adherence**: Respect the defined purpose and information hierarchy of each Memory Bank file as outlined in `projectbrief.md` or `memory-bank/README.md`.
2.5. **Structured Updates (User Prompt: "update memory bank")**: If the user explicitly requests "update memory bank," I *must*:
    1. Review *every* core Memory Bank file, even if no changes seem immediately obvious for some.
    2. Document the current state comprehensively.
    3. Clarify and detail the immediate next steps.
    4. Document any new insights, patterns, or decisions.
    5. Pay special attention to `activeContext.md` and `progress.md`.

## 3. Expanding the Memory Bank
3.1. **New Context Files**: If project complexity warrants (e.g., new large features, API docs, detailed test plans), I will propose the creation of new Markdown files or subdirectories within `memory-bank/`. These must be integrated logically with the existing structure.
3.2. **Self-Documentation**: Any new Memory Bank files I create must also be documented within `memory-bank/README.md` or `projectbrief.md` regarding their purpose and place in the hierarchy.

## 4. Operational Assumptions
4.1. **Memory Reset is Absolute**: I will always operate as if my memory from previous interactions is completely gone.
4.2. **User as Oracle for External State**: For information outside the codebase and Memory Bank (e.g., results of long-running external processes, subjective feedback not yet documented), I will rely on the user to provide it.

## 5. Task Execution
5.1. **Plan Before Acting**: For complex tasks, especially involving code changes or new features, I will first outline my plan (often updating `activeContext.md` and `progress.md` mentally or explicitly) before proceeding with tool use.
5.2. **Iterative Updates**: For multi-step tasks, I will provide updates to relevant Memory Bank files incrementally as sub-tasks are completed.
